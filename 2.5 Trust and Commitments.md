| 2.5 Trust and Commitments                                    | 2.5 信任和约定                                               |                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| In the last section, we made it so that Alice and Bob can actually exchange currency when they play Rock, Paper, Scissors!. However, the version of the application we wrote has a fundamental flaw: Bob can win every game! | 在上一节中，我们让 Alice 和 Bob 在玩石头剪刀布的时候可以交换货币。但是，我们编写的应用程序版本有一个根本性的漏洞： Bob可以赢得每场比赛！ |                                                              |                                                              |
| How is that possible? We showed executions of the game where Alice won, like the following | 这可能吗？我们接下来展示 Alice 获胜的过程：                  |                                                              |                                                              |
| $ ./reach run  Alice played Rock  Bob accepts the wager of 5.  Bob played Scissors  Alice saw outcome Alice wins  Bob saw outcome Alice wins  Alice went from 10 to 14.9999.  Bob went from 10 to 4.9999. | /reach 运行  Alice出石头  Bob下5 注  Bob出剪刀  Alice看到的结果是她赢了  Bob看到了Alice获胜  Alice筹码从10变成14.9999   Bob从10变成4.9999 |                                                              |                                                              |
| The problem is that this version of the game only executed an honest version of Bob, that is, one that followed the Reach program exactly, including in his private local steps. It is possible for a deviant and dishonest version of a Bob backend to execute different code and always win by computing the appropriate guess based on what value Alice provided for handA. | 问题是这个版本的游戏只执行了 Bob 的一个诚实版本，也就是说，一个完全遵循 Reach 程序的版本，包括在他的私有本地步骤中。对于一个离经叛道和不诚实的 Bob 后端版本来说，执行不同的代码并总是通过基于 Alice 为 hand A 提供的值计算适当的猜测来获胜是可能的。 |                                                              |                                                              |
| If we change Bob’s code to the following:                    | 如果我们将 Bob 的代码更改为：                                |                                                              |                                                              |
| tut-4-attack/index.rsh ..  // ... 25  B.only(() => { 26   interact.acceptWager(wager); 27   const handB = (handA + 1) % 3; }); 28  B.publish(handB) 29   .pay(wager); ..  // ... | tut-4-attack/index.rsh ..  // ... 25  B.only(() => { 26   interact.acceptWager(wager); 27   const handB = (handA + 1) % 3; }); 28  B.publish(handB) 29   .pay(wager); ..  // ... |                                                              |                                                              |
| then he will ignore the frontend and just compute the correct value. | 然后他会忽略前端，只计算正确的值。                           |                                                              |                                                              |
| If we run this version of the program, we will see output like this: | 如果我们运行这个版本的程序，我们会看到这样的输出：           |                                                              |                                                              |
| $ ./reach run  Alice played Scissors  Bob accepts the wager of 5.  Alice saw outcome Bob wins  Bob saw outcome Bob wins  Alice went from 10 to 4.9999.  Bob went from 10 to 14.9999. | reach 运行  Alice出剪刀  Bob下5注   Alice 看到了 Bob 获胜的结果  Bob看到了结果Bob赢了  Alice从10升到4.9999   Bob从10升到了14.9999。 |                                                              |                                                              |
| In this version, unlike the honest version, Bob never consults the frontend and so it never prints out the message of what hand Bob played. No matter what Alice chooses, Bob will always win. | 在这个版本中，不像之前诚实的版本，Bob从来没有查询前端，所以它从来没有给出出手信息。不管Alice怎么出，Bob都赢。 |                                                              |                                                              |
| Is it just a fluke of the random number generator that we observed Bob always winning? How would we know? Reach comes with an automatic verification engine that we can use to mathematically prove that this version will always result in the outcome variable equalling 0, which means Bob wins. We can instruct Reach to prove this theorem by adding these lines after computing the outcome: | 我们观察到 Bob 总是赢，这仅仅是随机数生成器的侥幸吗？我们如何知道的呢？Reach自带自动验证引擎，我们可以用它来从数学上证明这个版本总是会导致结果变量等于 0 ，这意味着 Bob 获胜。我们可以指示 Reach 在计算结果后添加这下面几行来证明这个定理： |                                                              |                                                              |
| tut-4-attack/index.rsh  ..  // ... 31  const outcome = (handA + (4 - handB)) % 3; 32  require(handB == (handA + 1) % 3); 33  assert(outcome == 0); 34  const [forA, forB] = ..  // ... Line 32 requires that the dishonest version of Bob be used for the proof.  Line 33 conducts the proof by including an assert statement in the program.  Before we had this line in the file, when we ran ./reach run, it would print out the message: | tut-4-attack/index.rsh  ..  // ... 31  const outcome = (handA + (4 - handB)) % 3; 32  require(handB == (handA + 1) % 3); 33  assert(outcome == 0); 34  const [forA, forB] = ..  // ... 32行要求用鲍勃的不诚实版本来证明。  第33行通过在程序中加入一个assert语句来进行证明。  在我们在文件中有这一行之前，当我们运行./reach run时，它会输出消息： |                                                              |                                                              |
| tut-3/index.txt  ..  // ...  2  Verifying for generic connector  3   Verifying when ALL participants are honest  4   Verifying when NO participants are honest  5   Verifying when ONLY "Alice" is honest  6   Verifying when ONLY "Bob" is honest  7  Checked 16 theorems; No failures!  But now, it prints out | Tt-3/index.txt  ..//…  2.验证通用链接器  3.验证所有参与者是否诚实 4.验证参与者是否均不诚实  5.验证只有“Alice”才是诚实的  6.验证只有“Bob”才是诚实的  检查了16个定理，没有失败！  但现在，它输出消息： |                                                              |                                                              |
| tut-4-attack/index.txt  ..  // ...  2  Verifying for generic connector  3   Verifying when ALL participants are honest  4   Verifying when NO participants are honest  5   Verifying when ONLY "Alice" is honest  6   Verifying when ONLY "Bob" is honest  7  Checked 21 theorems; No failures! | Tt-4-攻击/索引.txt ..//... 2.通用连接器的评定  3.当所有参与者都是诚实的时，核实所有参与者都是诚实的  4.无参与者诚实时的无偿性  只有“Alice”才是诚实的  6.只有“Bob”才是诚实的  检查了21个定理，没有失败！ |                                                              |                                                              |
| Line 7 is different and shows that more theorems have been proven about our program. It prints out five more, rather than one more, because the theorem is proved differently in the different verification modes. | 第 7 行是不同的，它表明关于我们的程序已经证明了更多的定理。因为在不同的验证模式下，定理的证明是不同的，所以它多输出 5 个，而不是 1 个。 |                                                              |                                                              |
| Many programming languages include assertions like this, but Reach is one of a small category where the compiler doesn’t just insert a runtime check for the property, but actually conducts a mathematical proof at compile-time that the expression always evaluates to true. | 许多编程语言都包含这样的判定，但 Reach 是其中的一个小类，编译器不只是为该属性插入运行时检查，而是实际上在编译时进行数学证明，证明表达式始终为 true 。 |                                                              |                                                              |
| In this case, we used Reach’s automatic verification engine to prove that an attack did what we expected it would. But, it is better to use verification to show that no flaw exists and no attack is possible. | 在本例中，我们使用了 Reach 的自动验证引擎来证明攻击的行为与我们预期的一样。但是，最好使用验证，以表明没有缺陷存在，没有攻击是可能的。 |                                                              |                                                              |
| Reach includes some such assertions automatically in every program. That’s why every version of Rock, Paper, Scissors! has said that a number of theorems were checked. We can see what these theorems do by deliberating inserting an error in the program. | reach 在每个程序中都自动包含一些这样的断言。这就是为什么《剪刀石头布》的每一个版本都说要检查一系列的定理。通过在程序中故意插入一个错误，我们可以看到这些定理的作用。 |                                                              |                                                              |
| Let’s change the computation of the payout and make it so that if Alice wins, then she only gets her wager back, not Bob’s. | 让我们改变结算规则，如果Alice赢了，那么她只得到她自己的筹码，而得不到Bob的。 |                                                              |                                                              |
| tut-4-attack/index-bad.rsh  ..  // ... 34  const [forA, forB] = 35     // was: outcome == 0 ? [0, 2] : 36     outcome == 0 ? [0, 1] : // <-- Oops 37     outcome == 1 ? [1, 1] : 38     [2, 0]; 39  transfer(forA * wager).to(A); 40  transfer(forB * wager).to(B); 41  commit(); ..  // ... Line 36 has [0, 1], but should have [0, 2].  When we run ./reach compile tut-4-attack/index-bad.rsh, it gives details about the error: | tut-4-attack/index-bad.rsh  ..  // ... 34  const [forA, forB] = 35     // was: outcome == 0 ? [0, 2] : 36     outcome == 0 ? [0, 1] : // <-- Oops 37     outcome == 1 ? [1, 1] : 38     [2, 0]; 39  transfer(forA * wager).to(A); 40  transfer(forB * wager).to(B); 41  commit(); ..  // ... 第 36 行有【 0 ， 1 】，但应该有【0， 2 】。 当我们运行./ reach 编译时tut-4-attack/index-bad.rsh,它给出了有关错误的详细信息： |                                                              |                                                              |
| tut-4-attack/index-bad.txt  ...    4  Verification failed:  5   when ALL participants are honest  6   of theorem: assert  7   msg: "balance assertion"  8   at ./index-bad.rsh:45:11:application  9    10   // Violation witness  11   const interact_Alice_wager = 2;  12   //  ^ from interaction at ./index-bad.rsh:14:12:application  13   const handA/4 = 2; | tut-4-attack/index-bad.txt  ...    4  Verification failed:  5   when ALL participants are honest  6   of theorem: assert  7   msg: "balance assertion"  8   at ./index-bad.rsh:45:11:application  9    10   // 虚假见证  11   const interact_Alice_wager = 2;  12   //  ^ from interaction at ./index-bad.rsh:14:12:application  13   const handA/4 = 2; |                                                              |                                                              |
| 14   //  ^ from evaluating interact("Alice")."getHand"() at ./index-bad.rsh:20:50:application  15    16   // Theorem formalization  17   const outcome/26 = (handA/4 + (4 - ((handA/4 + 1) % 3))) % 3;  18   //  ^ would be 0  19   const v37 = (outcome/26 == 0) ? [0, 1] : ((outcome/26 == 1) ? [1, 1] : [2, 0]);  20   //  ^ would be [0, 1]  21   assert(0 == (((interact_Alice_wager + interact_Alice_wager) - (v37[0] * interact_Alice_wager)) - (v37[1] * interact_Alice_wager)));  22    ... | 14   //  ^ from evaluating interact("Alice")."getHand"() at ./index-bad.rsh:20:50:application  15    16   // Theorem formalization  17   const outcome/26 = (handA/4 + (4 - ((handA/4 + 1) % 3))) % 3;  18   //  ^ would be 0  19   const v37 = (outcome/26 == 0) ? [0, 1] : ((outcome/26 == 1) ? [1, 1] : [2, 0]);  20   //  ^ would be [0, 1]  21   assert(0 == (((interact_Alice_wager + interact_Alice_wager) - (v37[0] * interact_Alice_wager)) - (v37[1] * interact_Alice_wager)));  22    ... |                                                              |                                                              |
| There’s a lot of information in the compiler output that can help an experienced programmer track down the problem. But the most important parts are | 编译器输出中有很多信息可以帮助有经验的程序员追踪问题。但最重要的部分是 |                                                              |                                                              |
| Line 7 says that this is an attempt to prove the theorem that the balance at the end of the program is zero, which means that no network tokens are sealed in the contract forever.  Line 8 says that this happens when the program exits on line 45, which directs the programmer to that path through the program.  Lines 10-14 describe the values that could cause the theorem to fail.  Lines 16-21 outline the theorem that failed. | 第 7 行说，这是试图证明的定理，在程序结束时的余额是0，这意味着没有网络令牌是永远密封在合约里。 第 8 行指出，这发生在第 45 行程序退出时，它引导程序员通过程序到达该路径。 第 10 - 14 行描述了可能导致定理失败的值。 第 16 - 21 行概述了失败的定理。 |                                                              |                                                              |
| These kinds of automatic verifications are helpful for Reach programmers, because they don’t need to remember to put them in their program, and they will still be protected from entire categories of errors.  —  However, now let’s add an assertion to the program that will ensure that every version of the program that allows Bob to know Alice’s hand before he chooses his own will be rejected. | 这些自动验证对 Reach 程序员是有帮助的，因为他们不需要记住把它们放在他们的程序中，而且他们仍然会受到保护，免受整个类别的错误。 — 但是，现在让我们向程序中添加一个断言，它将确保在 Bob 选择自己的之前允许 Alice 知道的程序的每个版本都将被拒绝 |                                                              |                                                              |
| We’ll go back to the version of tut-3/index.rsh from the last section, which has an honest version of Bob. (Click on the preceeding link if you need to see what it contained.)  We’ll add a single line to the program after Alice publishes, but before Bob takes a local step: | 我们将回到上一节中的 tut - 3 / index . rsh 版本，它有一个 Bob 的真实版本。（如果您需要查看它的内容，请单击前面的链接。） 在 Alice 之后，但是在 Bob 采取本地步骤之前，我们将在程序中添加一行： |                                                              |                                                              |
| tut-4-attack/index-fails.rsh  ..  // ... 21  A.publish(wager, handA) 22   .pay(wager); 23  commit(); 24   25  unknowable(B, A(handA)); 26  B.only(() => { 27   interact.acceptWager(wager); 28   const handB = declassify(interact.getHand()); }); ..  // ... | tut-4-attack/index-fails.rsh  ..  // ... 21  A.publish(wager, handA) 22   .pay(wager); 23  commit(); 24   25  unknowable(B, A(handA)); 26  B.only(() => { 27   interact.acceptWager(wager); 28   const handB = declassify(interact.getHand()); }); ..  // ... |                                                              |                                                              |
| Line 25 contains a knowledge assertion that Bob cannot know Alice’s value handA at this point in the program. In this case, it is obvious that this is not true, because Alice shares handA at line 21. In many cases, this is not obvious and Reach’s automatic verification engine has to reason about how values that Bob does know are connected to values that might be related to Alice’s secret values.  When we run ./reach run, it reports that this assertion is false: | 第25行包含一个额外的知识断言，即Bob不能知道Alice的值，HandA在程序的这一点上也是如此。在这种情况下，显然这不是真的，因为Alice在第21行共享Handa。在许多情况下，这一点并不明显，REACH的自动验证引擎必须考虑Bob所知道的值是如何与可能与Alice的机密值相关的值关联的。 当我们运行新的 ./reach run时，它会报告这个断言是错误的： |                                                              |                                                              |
| tut-4-attack/index-fails.txt  ..    3   of theorem unknowable("Bob", handA/7)  4   at ./index-fails.rsh:25:17:application  5    .. | tut-4-attack/index-fails.txt  ..    3   of theorem unknowable("Bob", handA/7)  4   at ./index-fails.rsh:25:17:application  5    .. |                                                              |                                                              |
| It is not enough to correct failures and attacks when you discover them. You must always add an assertion to your program that would fail to hold if the attack or failure were present. This ensures that all similar attacks are not present and that they will not accidentally be reintroduced.  —  Let’s use these insights into automatic verification and rewrite our Rock, Paper, Scissors! so that it is more trustworthy and secure. | 当你发现错误和攻击时，仅仅纠正它们是不够的。您必须始终向程序添加一个断言，如果存在攻击或故障，该断言将无法保持。这样可以确保所有类似的攻击都不存在，并且不会意外地再次引入。 — 让我们将这些见解应用到自动验证中，重写我们的“石头、布、剪刀”！使其更加值得信赖和安全。 |                                                              |                                                              |
| Since we’ve been making lots of changes to the code, let’s start fresh with a new version and we’ll look at every single line again, to make sure that you aren’t missing anything.  First, we’ll define the rules of Rock, Paper, Scissors! a little bit more abstractly, so we can separate the logic of the game from the details of the application: | 既然我们已经对代码做了很多修改，那么让我们从新的版本开始我们将再次检查每一行，以确保您没有遗漏任何内容。 首先，我们来定义剪刀石头布的规则！更抽象一点，这样我们就可以把游戏的逻辑和应用的细节分开： |                                                              |                                                              |
| tut-4/index.rsh 1  'reach 0.1'; 2   3  const [ isHand, ROCK, PAPER, SCISSORS ] = makeEnum(3); 4  const [ isOutcome, B_WINS, DRAW, A_WINS ] = makeEnum(3); 5   6  const winner = (handA, handB) => 7     ((handA + (4 - handB)) % 3); ..  // ... | tut-4/index.rsh 1  'reach 0.1'; 2   3  const [ isHand, ROCK, PAPER, SCISSORS ] = makeEnum(3); 4  const [ isOutcome, B_WINS, DRAW, A_WINS ] = makeEnum(3); 5   6  const winner = (handA, handB) => 7     ((handA + (4 - handB)) % 3); ..  // ... |                                                              |                                                              |
| Line 1 is the usual Reach version header.  Lines 3 and 4 define enumerations for the hands that may be played, as well as the outcomes of the game.  Lines 6 and 7 define the function that computes the winner of the game. | 第 1 行是通常的 Reach 版本号。 第3行和第4行定义了可以玩的手势，以及游戏的结果。 第6行和第7行定义了计算游戏赢家的函数。 |                                                              |                                                              |
| When we first wrote Rock, Paper, Scissors!, we asked you to trust that this formula for computing the winner is correct, but it is good to actually check. One way to check would be to implement a JavaScript frontend that didn’t interact with a real user, nor would it randomly generate values, but instead, it would return specific testing scenario values and check that the output is as expected. That’s a typical way to debug and is possible with Reach. However, Reach allows us to write such test cases directly into the Reach program as verification assertions. | 我们第一次写《剪刀石头布》的时候，我们要求您相信这个计算获胜者的公式是正确的，但是实际检查是好的。检查的一种方法是实现一个 JavaScript 前端，它不与真正的用户交互，也不会随机生成值，而是返回特定的测试场景值，并检查输出是否符合预期。这是一种典型的调试方式，在 Reach 中是可行的。然而， Reach 允许我们将这样的测试用例直接写入 Reach 程序，作为验证断言。 |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 9  assert(winner(ROCK, PAPER) == B_WINS); 10  assert(winner(PAPER, ROCK) == A_WINS); 11  assert(winner(ROCK, ROCK) == DRAW); ..  // ... | tut-4/index.rsh  ..  // ... 9  assert(winner(ROCK, PAPER) == B_WINS); 10  assert(winner(PAPER, ROCK) == A_WINS); 11  assert(winner(ROCK, ROCK) == DRAW); ..  // ... |                                                              |                                                              |
| Line 9 makes an assertion that when Alice plays Rock and Bob plays Paper, then Bob wins as expected. | 第 9 行断言，当 Alice 出石头 而 Bob出布 时，则 Bob 应当获胜  |                                                              |                                                              |
| But, Reach’s automatic verification allows us to express even more powerful statements about our program’s behavior. For example, we can state that no matter what values are provided for handA and handB, winner will always provide a valid outcome: | 但是， Reach 的自动验证允许我们表达关于程序行为的更有力的声明。例如，我们可以声明，无论 hand A 和 hand B 的值是什么，赢家总是会提供一个有效的结果： |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 13  forall(UInt, handA => 14   forall(UInt, handB => 15    assert(isOutcome(winner(handA, handB))))); ..  // ... And we can specify that whenever the same value is provided for both hands, no matter what it is, winner always returns DRAW: | tut-4/index.rsh  ..  // ... 13  forall(UInt, handA => 14   forall(UInt, handB => 15    assert(isOutcome(winner(handA, handB))))); ..  // ... 我们可以指定，每当为两只手提供相同的值时，无论是什么，获胜者总是返回DRAW： |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 17  forall(UInt, (hand) => 18   assert(winner(hand, hand) == DRAW)); ..  // ... | tut-4/index.rsh  ..  // ... 17  forall(UInt, (hand) => 18   assert(winner(hand, hand) == DRAW)); ..  // ... |                                                              |                                                              |
| These examples both use forall, which allows Reach programmers to quantify over all possible values that might be provided to a part of their program. You might think that these theorems will take a very long time to prove, because they have to loop over all 1,552,518,092,300,708,935,148,...247 digits...,468,750,892,846,853,816,057,856 possibilities (e.g., Ethereum uses 256-bits for its unsigned integers) for the bits of handA (twice!) and handB. In fact, on the author’s MacBook Pro from early 2015, it takes less than half a second. That’s because Reach uses an advanced symbolic execution engine to reason about this theorem abstractly without considering individual values. | 这两个示例都通用 ，这允许 Reach 程序员对可能提供给程序的一部分的所有可能值进行量化。你可能认为这些定理要花很长时间才能证明，因为它们必须遍历所有1552518092300708935148,...247digits...,468750892846853816057856可能性（例如，以太坊使用 256 位的无符号整数）的位 hand A （两次！）和 hand B 。事实上，在笔者 2015 年初的 MacBook Pro 上，这只需要不到半秒钟的时间。这是因为 Reach 使用一个高级的符号执行引擎抽象地推理这个定理，而不考虑单个值。 |                                                              |                                                              |
| Let’s continue the program by specifying the participant interact interfaces for Alice and Bob. These will be mostly the same as before, except that we will also expect that each frontend can provide access to random numbers. We’ll use these later on to protect Alice’s hand. | 让我们继续这个程序，为 Alice 和 Bob 指定参与者交互接口。这些将主要是与以前一样，除了我们也将期望，每个前端可以提供访问随机数。我们稍后会用这些保护Alice的手势。 |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 20  const Player = 21     { ...hasRandom, // <--- new! 22      getHand: Fun([], UInt), 23      seeOutcome: Fun([UInt], Null) }; ..  // ... The only line that is different is line 21, which includes hasRandom, from the Reach standard library, in the interface. | tut-4/index.rsh  ..  // ... 20  const Player = 21     { ...hasRandom, // <--- new! 22      getHand: Fun([], UInt), 23      seeOutcome: Fun([UInt], Null) }; ..  // ... 唯一不同的是第 21 行，它包含了 Reach 标准库中的 has Random 。 |                                                              |                                                              |
| tut-4/index.mjs  ..  // ... 20  const Player = (Who) => ({ 21   ...stdlib.hasRandom, // <--- new! 22   getHand: () => { 23    const hand = Math.floor(Math.random() * 3); 24    console.log(`${Who} played ${HAND[hand]}`); 25    return hand; 26   }, 27   seeOutcome: (outcome) => { 28    console.log(`${Who} saw outcome ${OUTCOME[outcome]}`); 29   }, 30  }); ..  // ... | tut-4/index.mjs  ..  // ... 20  const Player = (Who) => ({ 21   ...stdlib.hasRandom, // <--- new! 22   getHand: () => { 23    const hand = Math.floor(Math.random() * 3); 24    console.log(`${Who} played ${HAND[hand]}`); 25    return hand; 26   }, 27   seeOutcome: (outcome) => { 28    console.log(`${Who} saw outcome ${OUTCOME[outcome]}`); 29   }, 30  }); ..  // ... |                                                              |                                                              |
| Similarly, we only need to modify one line of our JavaScript frontend. Line 21 allows each participant’s Reach code to generate random numbers as necessary.  These two changes might look identical, but they mean very different things. The first, line 21 in the Reach program, adds hasRandom to the interface that the backend expects the frontend to provide. The second, line 21 in the JavaScript, adds hasRandom to the implementation that the frontend provides to the backend. | 同样，我们只需要修改 JavaScript 前端的一行。第 21 行允许每个参与者的 Reach 代码根据需要生成随机数。 这两个变化看起来可能是一样的，但它们的含义却截然不同。第一个部分， Reach 程序的第 21 行，将 hasRandom 添加到后端期望前端提供的接口。第二个， JavaScript 中的第 21 行，将 hasRandom 添加到前端提供给后端的实现中。 |                                                              |                                                              |
| We’re now at the crucial juncture where we will implement the actual application and ensure that Alice’s hand is protected until after Bob reveals his hand. The simplest thing would be to have Alice just publish the wager, but this, of course, would just leave Bob vulnerable. We need Alice to be able to publish her hand, but also keep it secret. This is a job for a cryptographic commitment scheme. Reach’s standard library comes with makeCommitment to make this easier for you. | 我们现在正处于关键时刻，我们将实现实际的应用程序，并确保 Alice 的手势受到保护，直到 Bob 显示他的手势。最简单的方法就是让 Alice 公布赌注，但这当然会让 Bob 很容易受到影响。我们需要 Alice 能够发表她的手，但也要保密。这是一个加密承诺方案的工作。reach 的标准库附带了 makecommitment ，让你更轻松地完成这个任务。 |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 36  A.only(() => { 37   const _handA = interact.getHand(); 38   const [_commitA, _saltA] = makeCommitment(interact, _handA); 39   const [wager, commitA] = declassify([interact.wager, _commitA]); }); 40  A.publish(wager, commitA) 41   .pay(wager); 42  commit(); ..  // ... | tut-4/index.rsh  ..  // ... 36  A.only(() => { 37   const _handA = interact.getHand(); 38   const [_commitA, _saltA] = makeCommitment(interact, _handA); 39   const [wager, commitA] = declassify([interact.wager, _commitA]); }); 40  A.publish(wager, commitA) 41   .pay(wager); 42  commit(); ..  // ... |                                                              |                                                              |
| Line 37 has Alice compute her hand, but not declassify it.  Line 38 has her compute a commitment to the hand. It comes with a secret "salt" value that must be revealed later.  Line 39 has Alice declassify the commitment and her wager.  Line 40 has her publish them and with line 41 has her include the wager funds in the publication. | 第 37 行有Alice计算她的手势，但没有公开。 第 38 行有她的承诺的手势。它还带有一个秘密的“salt”，以后一定要揭晓。 第 39 行Alice确定承诺和她的赌注。 第 40 行让她公开，第 41 行则让她在文章中加入赌注。 |                                                              |                                                              |
| At this point, we can state the knowledge assertion that Bob can’t know either the hand or the "salt" and continue with his part of the program. | 在这一点上，我们可以声明知识断言，即 Bob 既不知道手势，也不知道“salt”，然后继续他的程序部分。 |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 44  unknowable(B, A(_handA, _saltA)); 45  B.only(() => { 46   interact.acceptWager(wager); 47   const handB = declassify(interact.getHand()); }); 48  B.publish(handB) 49   .pay(wager); 50  commit(); ..  // ... | tut-4/index.rsh  ..  // ... 44  unknowable(B, A(_handA, _saltA)); 45  B.only(() => { 46   interact.acceptWager(wager); 47   const handB = declassify(interact.getHand()); }); 48  B.publish(handB) 49   .pay(wager); 50  commit(); ..  // ... | It is important to include the salt in the commitment, so that multiple commitments to the same value are not identical. Similarly, it is important not to share the salt until later, because if an attacker knows the set of possible values, they can enumerate them and compare with the result of the commitment and learn the value. | 重要的是要把salt值纳入承诺，这样对同一价值的多个承诺就不会完全相同。同样，重要的是不要共享salt值，直到稍后，因为如果攻击者知道一组可能的值，他们可以枚举它们，并与承诺的结果进行比较，并获取值。 |
| Line 44 states the knowledge assertion.  Lines 45 through 49 are unchanged from the original version.  Line 50 has the transaction commit, without computing the payout, because we can’t yet, because Alice’s hand is not yet public.  We now return to Alice who can reveal her secrets. | 第 44 行陈述了知识断言。 第45至49行与原始版本没有变化。 第 50 行有事务提交，没有计算 赔付t ，因为还不能，因为 Alice 的手势还没有公开。 现在让我们回到Alice身上，她能公开她的秘密。 |                                                              |                                                              |
| tut-4/index.rsh  ..  // ... 52  A.only(() => { 53   const [saltA, handA] = declassify([_saltA, _handA]); }); 54  A.publish(saltA, handA); 55  checkCommitment(commitA, saltA, handA); ..  // ... | tut-4/index.rsh  ..  // ... 52  A.only(() => { 53   const [saltA, handA] = declassify([_saltA, _handA]); }); 54  A.publish(saltA, handA); 55  checkCommitment(commitA, saltA, handA); ..  // ... |                                                              |                                                              |
| Line 53 has Alice declassify the secret information.  Line 54 has her publish it.  Line 55 checks that the published values match the original values. This will always be the case with honest participants, but dishonest participants may violate this assumption. | 第 53 行有Alice解密的秘密信息。 54 行让她公开了。 第 55 行检查已发布的值是否与原始值匹配。诚实的参与者总是这样，但不诚实的参加者可能会违背这个假设。 |                                                              |                                                              |
| The rest of the program is unchanged from the original version, except that it uses the new names for the outcomes: | 程序的其余部分与原始版本没有变化，只是使用了新的结果名称：   |                                                              |                                                              |
| tut-4/index.rsh ..  // ... 57  const outcome = winner(handA, handB); 58  const [forA, forB] = 59     outcome == A_WINS ? [2, 0] : 60     outcome == B_WINS ? [0, 2] : 61     [1, 1]; 62  transfer(forA * wager).to(A); 63  transfer(forB * wager).to(B); 64  commit(); 65   66  each([A, B], () => { 67   interact.seeOutcome(outcome); }); 68  exit(); }); | tut-4/index.rsh ..  // ... 57  const outcome = winner(handA, handB); 58  const [forA, forB] = 59     outcome == A_WINS ? [2, 0] : 60     outcome == B_WINS ? [0, 2] : 61     [1, 1]; 62  transfer(forA * wager).to(A); 63  transfer(forB * wager).to(B); 64  commit(); 65   66  each([A, B], () => { 67   interact.seeOutcome(outcome); }); 68  exit(); }); |                                                              |                                                              |
| Since we didn’t have to change the frontend in any meaningful way, the output of running ./reach run is still the same as it ever was: | 由于我们不需要以任何有意义的方式改变前端， running ./ reach run 的输出仍然与以前一样： |                                                              |                                                              |
| $ ./reach run  Alice played Scissors  Bob accepts the wager of 5.  Bob played Paper  Bob saw outcome Alice wins  Alice saw outcome Alice wins  Alice went from 10 to 14.9999.  Bob went from 10 to 4.9999. | $/到达运行 Alice出剪刀 Bob接受 5 英镑的赌注。 Bob出布 Bob看到了Alice获胜的结果 Alice看到的结果是Alice赢了 Alice从10变成了14.9999  Bob从10变成了4.9999。 |                                                              |                                                              |
| $ ./reach run  Alice played Paper  Bob accepts the wager of 5.  Bob played Scissors  Bob saw outcome Bob wins  Alice saw outcome Bob wins  Alice went from 10 to 4.9999.  Bob went from 10 to 14.9999. | $/到达运行 Alice玩起了纸 Bob下 5注。 Bob玩剪刀 Bob看到了结果Bob赢了 Alice 看到了 Bob 获胜的结果 Alice从10升到4.9999  Bob从10升到了14.9999。 |                                                              |                                                              |
| $ ./reach run  Alice played Scissors  Bob accepts the wager of 5.  Bob played Scissors  Bob saw outcome Draw  Alice saw outcome Draw  Alice went from 10 to 9.9999.  Bob went from 10 to 9.9999. | $/到达运行 Alice出剪刀 Bob下 5 注。 Bob出剪刀 Bob看到了抽签结果 Alice 看到了结果 Alice从10变成了9.9999。 Bob从10秒变成了9.9999。 |                                                              |                                                              |
| Except now, behind the scenes, and without any changes to the frontend, Alice now takes two steps in program and Bob only takes one, and she is protected against Bob finding her hand and using it to ensure he wins! | 除了现在，在幕后，没有任何变化的前端，Alice现在采取两个步骤的程序和Bob只需要一个，她是保护Bob发现她的手，并使用它，以确保他赢了！ |                                                              |                                                              |
| When we compile this version of the application, Reach’s automatic formal verification engine proves many theorems and protects us against a plethora of mistakes one might make when writing even a simple application like this. Non-Reach programmers that try to write decentralized applications are on their own trying to ensure that these problems don’t exist. | 当我们编译这个版本的应用程序时， Reach 的自动形式验证引擎证明了许多定理，并保护我们免受编写这样一个简单应用程序可能犯的大量错误。那些试图编写去中心化应用程序的非 R - R 程序员自己试图确保这些问题不存在。 |                                                              |                                                              |
| Now our implementation of Rock, Paper, Scissors! is secure and doesn’t contain any exploits for either Alice or Bob to guarantee a win. However, it still has a final category of mistake that is common in decentralized applications: non-participation. We’ll fix this in the next step; make sure you don’t launch with this version, or Alice may decide to back out of the game when she knows she’s going to lose! | 现在，我们实现的石头，布，剪刀！是安全的，不包含任何剥削，无论是Alice或Bob，以保证取胜。然而，它还有最后一类在分散应用程序中常见的错误：不参与。我们将在下一步解决这个问题；确保你不启动这个版本，否则Alice可能会决定退出游戏时，她知道她会输！ | If your version isn’t working, look at the complete versions of tut-4/index.rsh and tut-4/index.mjs to make sure you copied everything down correctly! | 如果您的版本不起作用，请查看完整的 tut - 4 / index . rsh 版本和 tut -4/index. mjs 版本，以确保正确地复制了所有内容！ |
|                                                              |                                                              | Check your understanding: True or false: Since blockchain programs run on a single, global, publicly-checked and certified consensus network, you don’t need to test them as much as normal software, which run on a wide variety of different platforms and operating systems. Answer: False | 检查你的理解：对或错： 由于区块链程序运行在一个单一的、全球的、经过公开检查和认证的共识网络上，你不需要像普通软件那样测试它们，它们运行在各种不同的平台和操作系统上。 答案是： 错 |
|                                                              |                                                              | Check your understanding: True or false: It is easy to write correct programs that handle financial information, and even if you make a mistake, blockchains support an "Undo" operation that allows you to rollback to earlier versions of the ledger to correct mistakes and recover lost funds. Answer: False | 检查你的理解：对或错： 编写处理财务信息的正确程序很容易，即使你犯了错误，区块链也支持“撤销”操作，允许你回滚到账本的早期版本，以纠正错误并收回损失的资金。 答案是： 错 |
|                                                              |                                                              | Check your understanding: True or false: Reach provides automatic verifications to ensure that your program does not lose, lock away, or overspend funds and guarantees that your applications are free from entire categories of errors. Answer: True | 检查你的理解：对或错：  Reach 提供自动验证，以确保您的程序不会丢失、锁定或超支资金，并保证您的应用程序不会出现所有类别的错误。 答案是： 对 |
|                                                              |                                                              | Check your understanding: True or false: Reach provides tools for you to add custom verifications to your program, like ensuring that information is known only to one party, or that your implementation of a sensitive algorithm is correct. Answer: True | 检查你的理解：对或错：  Reach 为您提供了向程序添加自定义验证的工具，比如确保信息仅为一方所知，或者确保敏感算法的实现是正确的。 答案是： 对 |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |
|                                                              |                                                              |                                                              |                                                              |